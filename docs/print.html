<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Canary</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">2.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/channels.html"><strong aria-hidden="true">2.1.</strong> Channels</a></li><li class="chapter-item expanded "><a href="concepts/services.html"><strong aria-hidden="true">2.2.</strong> Services</a></li><li class="chapter-item expanded "><a href="concepts/routes.html"><strong aria-hidden="true">2.3.</strong> Routes</a></li><li class="chapter-item expanded "><a href="concepts/providers.html"><strong aria-hidden="true">2.4.</strong> Providers</a></li></ol></li><li class="chapter-item expanded "><a href="examples.html"><strong aria-hidden="true">3.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.</strong> RPC System</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> Pub-Sub Server</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.</strong> Key-Value In-Memory Database</div></li><li class="chapter-item expanded "><a href="examples/final_challenge.html"><strong aria-hidden="true">3.4.</strong> Final Challenge</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Canary</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Canary is a simple distributed systems communication framework.
It provides a simple interface for you to code without having
to worry about the communication backend and more.</p>
<p>Canary's core principles are a high-level of abstraction and minimalism,
while keeping configurability and flexibility. Canary also strives
to be a zero-cost abstraction, offering as much performance as possible.</p>
<p>Canary is not opinionated on project structure and only provides tools and more
to make it easier to create distributed systems.</p>
<p>Unlike most distributed systems libraries, Canary has object stream-based communication
instead of rpc-based communication. This means that Canary is usually more performant than
other similar solutions such as gRPC and is comparable to websockets, but is more ergonomic
and usually performs better than websockets.</p>
<p>Still, this library may be a little too low-level for <em>some</em> use cases.</p>
<p>Should your project use Canary?
Canary fits these use cases perfectly.</p>
<ul>
<li>You want to build an RPC system</li>
<li>You want to build a consensus algorithm</li>
<li>You want to build a distributed system</li>
<li>You want to build a library for distributed systems</li>
<li>Anything that's got to do with distributed systems or communications</li>
</ul>
<p><strong>DISCLAIMER</strong></p>
<p>Canary is not yet on 1.0, which means that the API is prone to changes. Nevertheless,
the concepts should be stable <strong>BUT</strong> they are still prone to changes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>Canary has few core concepts that need to be fully understood before anything.</p>
<p>The concepts are the following:</p>
<ul>
<li>Channels</li>
<li>Services</li>
<li>Routes</li>
<li>Providers</li>
</ul>
<p>These concepts will be explained in the following chapters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channels"><a class="header" href="#channels">Channels</a></h1>
<p>Channels are a backend-agnostic way of communicating with peers.
You can think of it as a wrapper around a stream (tcp, udp or any other backend) that allows
you to send and receive objects or messages.</p>
<p>For example, let's assume you have connected Alice's machine and Bob's machine.</p>
<pre><pre class="playground"><code class="language-rust   no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use canary::{Channel, Result};

// runs on Alice's machine
async fn alice(mut chan: Channel) -&gt; Result&lt;()&gt; {
    chan.send(&quot;Hey Bob!&quot;).await?;
    Ok(())
}

// runs on Bob's machine
async fn bob(mut chan: Channel) -&gt; Result&lt;()&gt; {
    let message: String = chan.receive().await?;
    println!(&quot;alice says: `{}`&quot;, message); // alice says: `Hey Bob!`
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>It is important to note that you can send objects that
implement <code>Serialize</code> and receive objects that implement <code>Deserialize</code>.</p>
<p>Channels by default use Bincode for serialization, but they support various other
formats such as JSON, BSON and Postcard.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="services"><a class="header" href="#services">Services</a></h1>
<p>Services are functions that are stored on a route.</p>
<p>They take two parameters: metadata and a channel.
They also return a result, but failures are silently logged.</p>
<p>A simple service looks like this:</p>
<pre><pre class="playground"><code class="language-rust   no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use canary::{service, Channel, Result};

#[service]
async fn my_service(channel: Channel) -&gt; Result&lt;()&gt; {
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>Although barebones services might be enough for some use cases,
most use cases need to have context with the service (e.g. atomic counter, etc.)</p>
<p>For example, let's say Alice needs to build a counter service.
The service must count every call to the service and send back the current number.
A service like that could be implemented like this:</p>
<pre><pre class="playground"><code class="language-rust   no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use canary::{service, Channel, Result};
use std::sync::atomic::AtomicU64;
use std::sync::atomic::Ordering;
use std::sync::Arc;

#[service]
async fn counter_service(counter: Arc&lt;AtomicU64&gt;, mut peer: Channel) -&gt; Result&lt;()&gt; {
    let current_val = counter.fetch_add(1, Ordering::Relaxed);
    peer.send(current_val).await?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>These services can be registered on a route and exposed through a provider,
and they are designed to be embarrasingly parallel.</p>
<p>It's also important to know how these services get expanded, since the service macro does not cover all
use cases of services, for example, the macros in <code>SRPC</code> don't expand to service macros for generic support.</p>
<p>A simple service</p>
<pre><pre class="playground"><code class="language-rust   no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[service]
async fn get_id(counter: Arc&lt;u64&gt;, mut peer: Channel) -&gt; Result&lt;()&gt; {
    peer.send(counter).await?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>expands to this</p>
<pre><pre class="playground"><code class="language-rust   no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[allow(non_camel_case_types)]
struct get_id;
impl ::canary::service::Service for get_id {
    const ENDPOINT: &amp;'static str = &quot;get_id&quot;;
    type Pipeline = ();
    type Meta = Arc&lt;u64&gt;;
    fn service(
        __canary_inner_meta: Arc&lt;u64&gt;,
    ) -&gt; Box&lt;dyn Fn(::canary::igcp::BareChannel) + Send + Sync + 'static&gt; {
        async fn get_id(counter: Arc&lt;u64&gt;, mut peer: Channel) -&gt; Result&lt;()&gt; {
            peer.send(counter).await?;
            Ok(())
        }
        ::canary::service::run_metadata(__canary_inner_meta, get_id)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>and a simple SRPC implementation</p>
<pre><pre class="playground"><code class="language-rust   no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[srpc::rpc]
struct Counter {
    counter: u64
}

#[srpc::rpc]
impl Counter {
    async fn increase(&amp;mut self) -&gt; u64 {
        self.counter += 1;
        self.counter
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>expands to this</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Counter {
    counter: u64,
}
impl ::srpc::canary::routes::RegisterEndpoint for Counter {
    const ENDPOINT: &amp;'static str = &quot;counter&quot;;
}
struct CounterPeer(pub ::srpc::canary::Channel, ::core::marker::PhantomData&lt;()&gt;);
impl From&lt;::srpc::canary::Channel&gt; for CounterPeer {
    fn from(c: ::srpc::canary::Channel) -&gt; Self {
        CounterPeer(c, ::core::marker::PhantomData::default())
    }
}
impl ::srpc::Peer for Counter {
    type Struct = CounterPeer;
}
const _: () = {
    impl Counter {
        async fn increase(&amp;mut self) -&gt; u64 {
            self.counter += 1;
            self.counter
        }
    }
    #[allow(non_camel_case_types)]
    #[derive(Serialize_repr, Deserialize_repr)]
    #[repr(u8)]
    enum __srpc_action {
        increase,
    }
    impl ::srpc::canary::service::Service for Counter {
        const ENDPOINT: &amp;'static str = &quot;counter&quot;;
        type Pipeline = ();
        type Meta = ::std::sync::Arc&lt;::srpc::RwLock&lt;Counter&gt;&gt;;
        fn service(
            __srpc_inner_meta: ::std::sync::Arc&lt;::srpc::RwLock&lt;Counter&gt;&gt;,
        ) -&gt; Box&lt;dyn Fn(::srpc::canary::igcp::BareChannel) + Send + Sync + 'static&gt; {
            ::canary::service::run_metadata(
                __srpc_inner_meta,
                |__srpc_inner_meta: ::std::sync::Arc&lt;::srpc::RwLock&lt;Counter&gt;&gt;,
                 mut __srpc_inner_channel: ::srpc::canary::Channel| async move {
                    loop {
                        match __srpc_inner_channel.receive::&lt;__srpc_action&gt;().await? {
                            __srpc_action::increase =&gt; {
                                let res = __srpc_inner_meta.write().await.increase().await;
                                __srpc_inner_channel.send(res).await?;
                            }
                        }
                    }
                },
            )
        }
    }
    impl ::srpc::canary::service::StaticService for Counter {
        type Meta = ::std::sync::Arc&lt;::srpc::RwLock&lt;Counter&gt;&gt;;
        type Chan = ::srpc::canary::Channel;
        fn introduce(
            __srpc_inner_meta: ::std::sync::Arc&lt;::srpc::RwLock&lt;Counter&gt;&gt;,
            mut __srpc_inner_channel: ::srpc::canary::Channel,
        ) -&gt; ::srpc::canary::runtime::JoinHandle&lt;::srpc::canary::Result&lt;()&gt;&gt; {
            ::srpc::canary::runtime::spawn(async move {
                loop {
                    match __srpc_inner_channel.receive::&lt;__srpc_action&gt;().await? {
                        __srpc_action::increase =&gt; {
                            let res = __srpc_inner_meta.write().await.increase().await;
                            __srpc_inner_channel.send(res).await?;
                        }
                    }
                }
            })
        }
    }
    impl CounterPeer {
        pub async fn increase(&amp;mut self) -&gt; ::srpc::canary::Result&lt;u64&gt; {
            self.0.send(__srpc_action::increase).await?;
            self.0.receive().await
        }
    }
};
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="routes"><a class="header" href="#routes">Routes</a></h1>
<p>Routes are concurrent hashmaps that can store services and routes.
By default, Canary uses a global route, but a local ones can be created and worked with too.</p>
<p>Services are registered in routes and routes can also be registered in routes.</p>
<p>A route roughly looks like this:</p>
<pre><pre class="playground"><code class="language-rust   no_run">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Route {
               // name | service or route
    map: HashMap&lt;String, RouteValue&gt;
}

enum RouteValue {
    Route(Route),
    Service(Service),
}

<span class="boring">}
</span></code></pre></pre>
<p>Registering a service on a route looks like this (we're using the example from the services chapter):</p>
<pre><pre class="playground"><code class="language-rust   no_run">
use canary::{service, Channel, Result};
use std::sync::atomic::AtomicU64;
use std::sync::atomic::Ordering;
use std::sync::Arc;

#[main]
async fn main() -&gt; Result&lt;()&gt; {
                          // name of the service   |  metadata of service
    GLOBAL_ROUTE.add_service::&lt;counter_service&gt;(Arc::new(AtomicU64::new(0)))?;
    Ok(())
}

#[service]
async fn counter_service(counter: Arc&lt;AtomicU64&gt;, mut peer: Channel) -&gt; Result&lt;()&gt; {
    let current_val = counter.fetch_add(1, Ordering::Relaxed);
    peer.send(current_val).await?;
    Ok(())
}

</code></pre></pre>
<p>Routes can also be an abstraction over an actor, with services being their methods
and metadata being their state. Canary provides an ergonomic way of creating routes
as actors.</p>
<pre><pre class="playground"><code class="language-rust   no_run">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// this is the equivalent to the counter service,
// but implemented with routes.
// using this macro automatically implements `Register` to the structure.
// the register trait allows it to be registered under another route,
// which may be a nested route or the global route.


use canary::{Channel, Result};
use std::sync::atomic::AtomicU64;
use std::sync::atomic::Ordering;

use canary::route;

// this is an actor.
// doesn't need to be wrapped under an Arc as it is done automatically.
// do note that as services, actors only have read-access to their state.
#[route]
pub struct MyCounter(AtomicU64);

#[route]
impl MyCounter {
    async fn service(&amp;self, mut peer: Channel) -&gt; Result&lt;()&gt; {
        let current_val = self.0.fetch_add(1, Ordering::Relaxed);
        peer.send(current_val).await?;
        Ok(())
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>Registering the route should be as easy as this:</p>
<pre><pre class="playground"><code class="language-rust   no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_counter = Arc::new(MyCounter(AtomicU64::new(0)));
GLOBAL_ROUTE.register_route::&lt;MyCounter&gt;(my_counter)?;
<span class="boring">}
</span></code></pre></pre>
<p>Accessing the service looks like this:</p>
<pre><pre class="playground"><code class="language-rust   no_run">
use canary::Result;
use canary::providers::Tcp;

#[main]
async fn main() -&gt; Result&lt;()&gt; {
    // routes use PascalCase for their naming nomenclature
    // and services use snake_case
    let mut counter_service_chan = Tcp::connect(&quot;127.0.0.1:8080&quot;, &quot;MyCounter/service&quot;).await?;
    let current = counter_service_chan.receive().await?;
    println!(&quot;current value: {}&quot;, current);
}

</code></pre></pre>
<p>It is important to note that while it is possible to keep routes analogous to actors, they're very
different, and actors can be easily made with pure services without the need for routes. Still,
they're an important tool to keep up your belt while working with Canary. You'll get a sense
of when and where to use routes with experience.</p>
<p>A good rule to avoid name collisions on the global route is that libraries should not use the global route,
but instead provide register implementations for their services and routes.</p>
<p>Binaries should be able to use the global route directly.</p>
<p>Don't forget to also create drop implementations on the services and routes to avoid memory leaks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="providers"><a class="header" href="#providers">Providers</a></h1>
<p>Providers are a way of exposing a route (usually the global route)
for external access.</p>
<p>A simple example of a provider is the insecure TCP provider,
which provides non-encrypted TCP channels to a route.</p>
<p>Providers offer a simple interface for exposing routes through them.
An example of a TCP provider in use:</p>
<pre><pre class="playground"><code class="language-rust   no_run">
use canary::{service, Channel, Result};
use std::sync::atomic::AtomicU64;
use std::sync::atomic::Ordering;
use std::sync::Arc;

use canary::providers::Tcp;

#[main]
async fn main() -&gt; Result&lt;()&gt; {
    // bind the global route to this tcp socket
    Tcp::bind(&quot;127.0.0.1:8080&quot;).await?;
    GLOBAL_ROUTE.add_service::&lt;counter_service&gt;(Arc::new(AtomicU64::new(0)))?;
    Ok(())
}

#[service]
async fn counter_service(counter: Arc&lt;AtomicU64&gt;, mut peer: Channel) -&gt; Result&lt;()&gt; {
    let current_val = counter.fetch_add(1, Ordering::Relaxed);
    peer.send(current_val).await?;
    Ok(())
}

</code></pre></pre>
<p>Accessing the counter service should be as easy as:</p>
<pre><pre class="playground"><code class="language-rust   no_run">
use canary::Result;
use canary::providers::Tcp;

#[main]
async fn main() -&gt; Result&lt;()&gt; {
    let mut counter_service_chan = Tcp::connect(&quot;127.0.0.1:8080&quot;, &quot;counter_service&quot;).await?;
    let current = counter_service_chan.receive().await?;
    println!(&quot;current value: {}&quot;, current);
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>To prepare yourself to build custom distributed systems,
you will have to build a set of distributed systems with Canary.</p>
<p>Some examples have been prepared for you to build along,
and a final challenge for you to try building individually.</p>
<p>The examples you have to build are the following (in order):</p>
<ul>
<li>An RPC system.</li>
<li>A pub-sub server.</li>
<li>A key-value in-memory database.</li>
</ul>
<p>Do note that it is assumed that you have used the Rust programming language
and are comfortable with it, as some of these projects can be demanding.</p>
<p>If you still don't understand how things work, don't be afraid to take a look
at the code, since the codebase is relatively small; Canary is implemented in ~600 sloc,
and igcp (the library that provides channels) is implemented in ~900 sloc.</p>
<p>You can also take a look at the code from <a href="https://github.com/znx3p0/saildb">SailDB</a>, a key-value in-memory database designed to be
extremely simple and performant, but it uses SRPC as a backend for writing services.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="final-challenge"><a class="header" href="#final-challenge">Final Challenge</a></h1>
<p>The final challenge is to build a distributed consensus algorithm.</p>
<p>Attempts at this challenge should be added to this list as an example:</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
