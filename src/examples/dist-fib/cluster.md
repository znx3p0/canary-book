# Cluster

The protocol defined the cluster as having a connection to the nodes,
so in this sense, the cluster has a list of the connected nodes.

This structure can be defined as the following:
```rust , no_run
struct Cluster {
    nodes: Vec<NodePeer>,
}
```

The `#[srpc::rpc]` macro autogenerated the peer of the Node and named it `NodePeer`.

Now, we have to define the RPC's from the cluster.
We only need the cluster to do two things externally:
- Add nodes
- Compute fibonacci

To do this, we can start with the distributed compute implementation:
```rust , no_run
#[srpc::rpc]
impl Cluster {
    async fn calculate_fib(&mut self, num: u32) -> u32 {
        if self.nodes.is_empty() {
            println!("calculating fib locally");
            // no nodes :(
            // calculate fib locally instead
            return fibonacci(num)
        }

        // get a random node and ask it to compute fibonacci
        let node_num = fastrand::usize(..self.nodes.len());
        let node = &mut self.nodes[node_num];
        println!("sending op to node");
        match node.fibonacci(num).await {
            Ok(res) => res,
            Err(_) => {
                println!("calculating fib locally and removing node");
                // error :(
                // calculate fib locally instead
                // and remove this node since it is unreliable
                self.nodes.remove(node_num);
                fibonacci(num)
            }
        }

    }
}
```

We can now easily calculate fibonacci from a cluster peer, but there's one thing left:
adding nodes to the cluster.

Peers are made from channels, a `Channel` can be turned into a Peer through `IntoClient`,
but there's a problem. How do we consume the channel backing the RPC?

We can consume the channel by using the `#[consume]` attribute on the method.

```rust , no_run
#[consume]
async fn insert_node(&mut self, chan: Channel) -> Result<()> {
    let chan = chan.client::<DistributedFibNode>();
    self.nodes.push(chan);
    Ok(())
}
```

The complete implementation of the cluster should look like this:
```rust , no_run
#[srpc::rpc]
#[derive(Default)]
struct DistributedFibCluster {
    nodes: Vec<DistributedFibNodePeer>,
}

#[srpc::rpc]
impl DistributedFibCluster {
    #[consume]
    async fn insert_node(&mut self, chan: Channel) -> Res<()> {
        let chan = chan.client::<DistributedFibNode>();
        self.nodes.push(chan);
        Ok(())
    }
    async fn calculate_fib(&mut self, num: u64) -> u64 {
        if self.nodes.is_empty() {
            println!("calculating fib locally");
            // no nodes :(
            // calculate fib locally instead
            return fibonacci(num)
        }
        let node_num = fastrand::usize(..self.nodes.len());
        let node = &mut self.nodes[node_num];
        println!("sending op to node");
        match node.fibonacci(num).await {
            Ok(res) => res,
            Err(_) => {
                println!("calculating fib locally and removing node");
                // error :(
                // calculate fib locally instead
                // and remove this node since it is unreliable
                self.nodes.remove(node_num);
                fibonacci(num)
            }
        }

    }
}
```

